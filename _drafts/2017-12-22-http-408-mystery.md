---
published: false
---
I ran into a tricky problem the other day at $WORK and thought it would be a good idea to share it here, if at least to make a note of it for later.

We had some devices on a client's network that wouldn't connect back to our servers anymore. As always in this case, nobody changed anything anywhere but it stopped working nonetheless.
Anyway, looking at our logs I noticed some weird HTTP 408 errors. First time I saw that so I went looking for an explanation on the Internets: turns out it indicates that a client initiated a TCP connection to the server but didn't send HTTP traffic afterwards before the server timeout kicked in.
On Apache, this timeout is set by default to 20s. I captured some traffic with tcpdump to check what was happening and indeed the TCP connection was closed by the server after 20s.
Now I should point out that our devices connect over HTTPS. I got the logs from one of those devices and found that on its side the connection failed because it couldn't negociate the TLS session: there was a certificate error. Weird because we make sure to embed our TLS certs in the devices themselves.
After debriefing with our customer and showing that we were clean on our side, said customer started to investigate.
He came back to us explaining that our devices didn't support his SSL inspection equipment and he had to exclude our devices traffic from it. They were now getting back online.
I knew SSL inspection (or TLS interception) was a thing but never bothered to research how it's actually working.
So now that I have, here is a quick explanation.
First you need to know that our customer had to deploy a specific TLS certificate to be trusted by every devices he wanted to inspect the traffic of. That TLS certificate has been generated by his SSL inspection equipment so it can perform what is basically a man-in-the-middle attack on all corporate TLS traffic.

[diagram]

1.The device connects to the proxy doing SSL inspection
2.The device starts negociating a TLS session with the proxy because it is impersonating the destination server
2.The proxy initiates another connection to the destination server
3.The proxy negociates the TLS session with the destination server
4.The proxy finishes the TLS negociation with the device
5.The device refuses to accept

Whether it's an additional CA certificate pushed to your browser by your IT or maliciously added to a browser CA bundle, there are a lot of ways TLS interception can be performed. And ~~victims~~users are not always aware of that.
The good news is that it can easily be detected from the client side by [checking some well known TLS certificate fingerprints (tool)](https://www.grc.com/fingerprints.htm) and looking for differences.
Web servers can also detect TLS interception by [comparing User-Agent headers and the way TLS negocation is performed (paper)](https://jhalderm.com/pub/papers/interception-ndss17.pdf).

I have mixed feelings about this topic: on one hand, as we see unencrypted communications slowly disappear from the Internet, there are some legitimate use cases for being able to inspect TLS sessions. Malware detection being one. On the other hand, I still feel this is an attack on privacy and we at least need to make it more obvious when TLS traffic is intercepted. This has to be built into web browsers like certificate validation aka "green lock" has been so people are aware of that and can decide whether the network they're on is secure enough for their communications or not.